# 环境变量

==环境变量关系==
首先，我来说一下他们之间的关系：环境变量只是一个总称，代表了系统变量和用户变量，因此我们说环境变量都是指的系统变量和用户变量。

系统变量就是系统级别的变量，用户需要使用系统变量。**如果系统变量被修改了，而任何系统用户都在用系统变量，因此每个系统用户都将受到影响。**用户变量运行在系统变量之上的，每个用户拥有不同的用户变量，不同用户的用户变量之间是并列的，也是互不干扰的。他们之间的关系图如下如所示

![image-20221102233050948](./assets/image-20221102233050948.png)

==为什么输入几个符号就能显示相应的提示？==

不知道有没有人有疑问，为什么我在命令行里面输入几个字符，按下回车，屏幕就会显示相应的提示。

你在命令行里输入的那几个符号，其实就是一些可执行程序的名字(标签、别名)，是可以直接被当前系统直接执行的程序。如果是在Windows系统中，则这些被输入的符号就是可以直接被windows系统执行、后缀为`.exe`的程序(文件)。

再比如如在Linux中，输入的字符则是被叫做可执行的文件，这里可执行文件意义等同于Windows中的后缀为'.exe'的文件(程序)，这里值得说明的是：Linux中是不存在通过后缀名来识别文件类型的，即使存在也仅仅只是为了帮助记忆，或者便于人们识别而已。

众所周知，程序是给机器阅读的，所以，这些可执行的程序或文件大多是机器码，不是人类可识别的字符。Linux中的可执行文件(程序)不可以在Windows中去运行，因为Linux系统不是Windows系统(每个系统执行程序或运行代码的方式是不同的)。

==命令行中的程序来自哪里？==

我第一次接触命令行
本文作者最开始遇到这个问题的时候在初学Java程序的时候。学习Java程序需要配置环境变量，如果环境变量配置不成功，在命令行中去输入'java'就会提示'找不到xxxx'的一类的关键词。通过第二节大概知道为什么了，你输入的这个java字符就是代表可执行程序

程序来自于哪里？
其实这个叫`java`的应用程序就在你的安装目录下面的`bin`目录中。所有软件(包括Java在内的所有软件)安装目录下bin目录中，均代表里面放的是可执行的机器码(程序文件)，也就是给机器阅读(执行)的文件(程序)。

==执行程序跟环境变量有什么关系？==

咋们来看看windows中的环境变量截图

![image-20221102233439833](./assets/image-20221102233439833.png)



变量关系截图
命令行之所以能执行这个程序，是因为环境变量。

在上面的截图中可以看得出，变量都只是一个名字，真正起到作用的是变量的值，可以看到变量值中大部分都是目录路径，少部分可以看到'.exe'结尾的程序，目录是用来干嘛的？就是用来给命令行搜索程序文件的，你在环境变量值中填写的目录路径，会被命令行遍历目录中的内容，而你知道的目录下都是些可执行程序。那么这个时候命令行输入的命令都会在这些变量值中的目录去找程序，如果找到了跟在命令行中输入的名字(字符)一模一样的程序名，那么命令行就会执行这个程序，以达到执行命令行程序的功能

因此，所有在命令行中去执行的程序，其位置均储存在环境变量目录值中，我们在执行命令行中程序的时候，其实就是在查找环境变量所有程序位置中有没有(是否找得到)这个程序，如果没有就会提示'未找到'等关键词，如果在环境变量中找到了你在命令行中输入的程序名字，那么通过环境变量就可以直接去执行程序。

==为什么需要环境变量？==
在电子计算机出现之初，命令行就出现了。最开始的时候，人们(少数)都是使用的命令行，后来图形化的电子计算机的出现，命令行的计算机才从普通消费者印象中渐渐消失殆尽，所以命令行是计算机最开始的就有的了。那为什么现在命令行还没有消失？因为它有不可替代的优势：高效、快捷。

图形界面只是方便非IT专业的人们准备的，图形界面看起来友好，不需要太好的逻辑就能操作系统，这也就是为什么后来Windows快速占领市场，而同样非常优秀的Linux却只能听起来像神话一样的存在。

 ==注意==



Windows系统中有两种[环境变量](https://so.csdn.net/so/search?q=环境变量&spm=1001.2101.3001.7020)：用户变量和系统变量

1. 环境变量不区分大小写，例如path跟PATH是一样的
2. 系统变量对所有用户有效而用户变量只对当前用户有效
3. 用户变量与系统变量，名称是变量，值是里面的内容，也就是通过变量存储了想要存储的内容，方便调用
4. 系统变量与用户变量的PATH：告诉系统可执行文件放在什么路径（平常执行程序的路径，要放在PATH里面，不能建一个变量，cmd会提示“不是内部或外部命令，或者不是可执行程序”）
5. windows系统在执行用户命令时，若用户未给出文件的绝对路径，则首先在当前目录下寻找相应的可执行文件、批处理文件等；如果当前目录找不到对应文件名的程序，在系统变量的PATH的路径中，依次寻找对应的可执行程序文件（查找顺序是按照路径的录入顺序从左往右寻找的，最前面一条的优先级最高，如果找到程序就停止寻找，后面的路径不再执行）
6. 如果系统变量的PATH的路径找不到，再到用户变量的PATH路径中寻找（==如果系统变量和用户变量的PATH中同时包含了同一个命令，则优先执行系统变量PATH中的命令）==
7. 每次新加了命令以后，要确定保存了。再重启CMD，否则命令不生效的。

![image-20221102232832936](./assets/image-20221102232832936.png)



==案列==

[Win10如何配置Python的环境变量 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/263000046)





# x86和x64

## 狭义的x86架构

指只支持32位的intel/AMD/VIA的CPU，并向下兼容16位（实模式）

## 狭义的x64架构

指的是支持32位和64位的intel/AMD CPU，指令集与x86兼容，并向下兼容16位（实模式），目前绝大多数民用CPU和服务器CPU都是这样的；

两大优点：

- 可以进行更大范围的整数运算；
- 可以支持更大的内存。

不能因为数字上的变化，而简单的认为64bit处理器的性能是32bit处理器性能的两倍。

实际上在32bit应用下，32bit处理器的性能甚至会更强，

即使是64bit处理器，也可能是在32bit应用下性能更强。

所以要认清64bit处理器的优势，但不可迷信64bit。

# 解决方案

## 解决方案不和源代码放一个目录

> #### 中间文件放在各自文件夹，lib,exe,dll文件均放在x64/Debug/文件夹下

![image-20221106140013200](./assets/image-20221106140013200.png)

![image-20221106140046581](./assets/image-20221106140046581.png)



![image-20221106190020019](./assets/image-20221106190020019.png)

## ==如果放在一个目录的话==

> #### 中间目录放在一起

![image-20221106140338135](./assets/image-20221106140338135.png)

![image-20221106190430858](./assets/image-20221106190430858.png)





## 编译后新增的文件(x64)

![image-20221106123317915](./assets/image-20221106123317915.png)

![image-20221106123514132](./assets/image-20221106123514132.png)

> #### 如果选用的是x86这直接在目录下就有debug文件

![image-20221106134034683](./assets/image-20221106134034683.png)



## 各文件夹包含关系

![img](./assets/007S8ZIlgy1gh6jguaxryj31bt0rsjxr.jpg)

### 最终目标文件输出目录

![image-20221106135714362](./assets/image-20221106135714362.png)



### 中间结果输出目录



一般来说，vs中的c++项目的解决方案总文件夹下包含==解决方案配置文件sln==和==一个项目总文件夹==和一个==Debug文件夹==以及一个==Release文件夹==（共四个文件夹，其中Debug和Release文件夹中存放最终生成的结果exe或dll，如果不使用Release生成，则不存在Release文件夹）。

而解决方案和项目文件夹包含关系下包含C++源文件头文件、项目配置文件和一个Debug文件夹以及一个Release文件夹（注意，此处的Debug和Release文件夹仅仅存放中间编译结果obj，不存放exe和dll之类的东西。如果不使用Release编译，则没有对应的Release文件夹）。

![image-20221102230923814](./assets/image-20221102230923814.png)







`sln`是解决方案文件，为解决方案[资源管理器](https://so.csdn.net/so/search?q=资源管理器&spm=1001.2101.3001.7020)提供显示管理文件的图形接口所需的信息

`sdf` (SQL Server Compact Edition Database File)文件，是工程的信息保存成了数据库文件，如果你没有参加大型的团队项目，不涉及到高深的调试过程，这个文件对于你来说没什么用了，可以放心的删除，如果你后来又需要这个文件了，简单，打开工程里的.sln文件重新编译链接就ok了

`vcxproj`文件：工程文件，其中描述了工程的各项属性，修改该文件后再重新build时vs会重新build工程

`vcxproj.filter`文件：可理解为视图文件，定义了工程在`VS`中打开后的目录结构，修改该文件后重新build时vs不会重新build工程

`vcxproj.user`是本地化用户配置，允许多个用户使用自己喜好的方式配置这个项目（例如打开项目时候窗体位置等与项目内容无关的配置）

## debug和release

> Debug 版本

Debug 是“调试”的意思，Debug 版本就是为调试而生的，编译器在生成 Debug 版本的程序时会加入调试辅助信息，并且很少会进行优化，程序还是“原汁原味”的。

你没听错，不是任何一个程序都可以调试的，程序中必须包含额外的辅助信息才能调试，否则调试器也无从下手。

> Release 版本

Release 是“发行”的意思，Release 版本就是最终交给用户的程序，编译器会使尽浑身解数对它进行优化，以提高执行效率，虽然最终的运行结果仍然是我们期望的，但底层的执行流程可能已经改变了。

编译器还会尽量降低 Release 版本的体积，把没用的数据一律剔除，包括调试信息。

最终，Release 版本是一个小巧精悍、非常纯粹、为用户而生的程序。

> #### 总结

Debug：调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。==Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息==

Debug 版本的存在是为了方便程序员开发和调试，性能和体积不是它的重点；

Release 版本是最终交给用户的程序，性能和体积是需要重点优化的两个方面。

在开发过程中，我们一般使用 Debug 版本，只有等到开发完成，确认没有任何 Bug 之后，希望交给用户时再生成 Release 版本。

基本所有的集成开发环境（IDE）都可以在 Debug 版本和 Release 版本之间进行切换.

![image-20221102231307986](./assets/image-20221102231307986.png)

## 生成、重新生成、清理解决方案


首先，在Visual Studio中，一个解决方案是可以包含一个或多个项目的。

若对整个解决方案：

1.在“解决方案资源管理器”，选择或打开解决方案。 

2.在菜单栏上，依次选择“生成”，然后选择以下命令之一： 

* 选择==“生成”==或“==生成解决方案”==生成最近生成更改的那些项目文件和组件（注：如果解决方案中包括多个项目，则“生成”命令将变成“生成解决方案”）。 
* 选择“==重新生成解决方案”==后，先清理解决方案然后再生成所有项目文件和组件。 
* 选择==“清理解决方案”==删除所有中间文件和输出文件。仅使用项目和组件文件，则个中间文件和输出文件的新实例可以生成。


若当前解决方案只有一个项目：

1.解决方案资源管理器，选择或打开项目。 

2.在菜单栏上，依次选择 生成，然后选择生成ProjectName 或 重新生成ProjectName。 

a、选择 生成ProjectName 生成最近生成更改的那些项元素。

b、选择 重新生成ProjectName 后，先“清理”项目然后生成项目文件和所有项目元素。


只生成启动项目及其依赖项：

1. 在菜单栏上，依次选择 工具，选项。 

2. 在 选项 对话框中，展开 项目和解决方案 节点，然后选择 生成并运行 页。 

生成并运行，项目和解决方案，选项 对话框打开。 

3. 选择 在运行时仅生成启动项目和依赖项 复选框。 

当该复选框处于选中状态，因此，只有当前启动项目及其依赖项后，当您执行以下步骤之一： 

在菜单栏上，依次选择 调试，启动 (f5)。 

在菜单栏上，依次选择 生成，生成解决方案 (ctrl+shift+b)。 

如果清除此复选框，所有项目、它们的依赖项和解决方案文件生成，当您运行上述任一命令时。  默认情况下会清除此复选框。


停止生成：

任意执行以下步骤之一： 

在菜单栏上，依次选择 生成，取消。 

选择 Ctrl + 断路键。

# 预编译头

接下来我们需要将`pch.cpp` `pch.h` `framework.h`都删除，只保留`dllmain.cpp`。

在解决方案中，选择方案名称后鼠标右键弹出菜单，选择“属性”，或者在菜单中选择“项目”->“属性”，或者快捷键“Alt+Enter”。在属性页面中选择“C/C++”下的“预编译头”，配置成不使用预编译头。

![image-20221102230438519](./assets/image-20221102230438519.png)

# 配置路径

## 目录名宏定义

### `$SolutionDir`

![image-20221107000656024](./assets/image-20221107000656024.png)

![image-20221103003057064](./assets/image-20221103003057064.png)

![image-20221103003146893](./assets/image-20221103003146893.png)

### `Platform`

![image-20221103003253433](./assets/image-20221103003253433.png)

### `$Configuration`

![image-20221103095111695](./assets/image-20221103095111695.png)



![image-20221103095149478](./assets/image-20221103095149478.png)





## 输出目录

输出目录-决定`$(OutDir)`,即设置了VS的“输出目录”属性就相当于设置了`$(OutDir)`的值。

如果我们建立一个默认的vc项目`ssyy`，他的默认“常规“栏目中，“输出目录”为`\$(SolutionDir)$(ConfigurationName)`，所以调试时会在解决方案文件夹下建立一个`debug`（`ConfigurationName`的值为debug）文件夹，并在此文件夹下生成` ssyy.lik`链接器 和`ssyy.exe`文件(默认情况下) 。

![image-20221103001037002](./assets/image-20221103001037002.png)



![image-20221103002627064](./assets/image-20221103002627064.png)

![image-20221103002858639](./assets/image-20221103002858639.png)



![image-20221103001344968](./assets/image-20221103001344968.png)

![image-20221103001601102](./assets/image-20221103001601102.png)

![image-20221103001641390](./assets/image-20221103001641390.png)



## 中间目录

![image-20221103095352955](./assets/image-20221103095352955.png)

![image-20221103095321745](./assets/image-20221103095321745.png)





默认“中间目录”为`$(ConfigurationName)`，所以会在ssyy项目文件夹下（即`ssyy.vcproj`的项目配置文件所在位置）建立一个debug文件夹，并在该文件夹下生成ssyy.obj二进制文件。

默认“链接器”栏目下的“常规”选项下的“输出文件”选项为$(OutDir)$(ProjectName).exe，其中$(OutDir)就已经在“常规”栏目的“输出目录”选项赋值了。

注意：实际上输出目录不决定输出`exe`文件的位置。

2、输出文件-决定$(TargetDir)
$(TargetDir)的值是在生成exe文件后自动赋予值为exe文件所在位置。所以可以说，“输出文件”最终决定exe文件所在的位置。

默认情况下“输出目录”和“输出文件”两个属性对应的目录是一样的，这样用着方便（当然，输出文件的值在输出目录的值的基础上还包含有exe文件名）。如果两个不一样，则中间生成的链接器用的如xx.ilk和xx.pdb文件等在输出目录，而最终生成的xx.exe文件在“输出文件”属性设置的目录中。

当调试程序时，系统变量$(OutDir)的值是最先确定的，而$(TargetDir)和$(TargetPath)的值是在exe文件生成后才确定的。也就是说系统变量$(OutDir)的值由VS项目的“输出目录”属性决定，而$(TargetDir)和$(TargetPath)的值由VS项目的“输出文件”属性决定。

3、工作目录
“调试”栏目中的“工作目录”项，这个属性默认情况下是空的，但表示工作目录是工程目录，也就是工程配置文件ssyy.vcproj所在目录。

“工作目录”属性作用是程序运行后唯一识别的默认目录，即工作后只认识这个目录。

例如程序运行过程中生成一个txt文本文件，如果在创建文件过程中未指定绝对路径，只指定创建文件的文件名，那么这个文本文件默认就会建立在工作目录中，当然读取一些配置文件也在工作目录中查找，但要说明一下，生成的exe文件跟工作目录没任何关系，也不会放在工作目录中。总的来说，工作目录就是程序运行过程中默认读取的目录。

【对工作目录的补充：

vs中工作目录的设置是给调试用的，也即你启动调试后，启动一个新进程，自动把这个新进程的工作目录设置为vs项目属性中的工作目录，然后新进程启动对应的exe程序。

但是如果不使用vs的调试启动exe，而是直接双击exe文件启动一个新进程时，会自动把这个新进程的工作目录设置为exe文件所在的目录，这是和vs启动调试不同的地方。所以如果发布的时候不把工作目录内的东西拷到exe所在的目录内，就会运行出错，因为此时工作目录不再是vs中设置的了，而是exe文件所在的目录。

上面所说的“调试”是指vs下启动exe，包括debug模式和release模式，不要把调试就理解为只有debug模式。】

如果工程中用到的文件不在默认的工作目录下，而程序中又直接使用了相对路径，则应修改工作目录。

参考文档
————————————————
版权声明：本文为CSDN博主「Xieyh@CUC」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41821317/article/details/107640638

# 添加模块定义文件



![image-20221103104638769](./assets/image-20221103104638769.png)



![image-20221106191036631](./assets/image-20221106191036631.png)

如果想兼容c语言



![img](./assets/187222EC5968BE400CC265210C55FC24.png)



# 动态库和静态库

## 介绍

![image-20221103121345686](./assets/image-20221103121345686.png)

![image-20221103121422723](./assets/image-20221103121422723.png)

![image-20221103121640546](./assets/image-20221103121640546.png)

## 静态库配置方法

### 创建静态库

![image-20221103122740010](./assets/image-20221103122740010.png)

![image-20221103123415721](./assets/image-20221103123415721.png)

### 使用静态库

#### 第一种方式

==第一步：引入静态库==

![image-20221103123732406](./assets/image-20221103123732406.png)

![image-20221103123927455](./assets/image-20221103123927455.png)

==第二步：include 静态库头文件==

![image-20221103124147890](./assets/image-20221103124147890.png)

![image-20221103124228691](./assets/image-20221103124228691.png)

![image-20221103124332941](./assets/image-20221103124332941.png)

#### 第二种方式

![image-20221103125551911](./assets/image-20221103125551911.png)

![image-20221103125954917](./assets/image-20221103125954917.png)

#### 第三种方式

![image-20221103130426872](./assets/image-20221103130426872.png)

![image-20221103130502964](./assets/image-20221103130502964.png)

![image-20221103130956565](./assets/image-20221103130956565.png)

![image-20221103131145861](./assets/image-20221103131145861.png)

## 动态库创建

![image-20221105233002259](./assets/image-20221105233002259.png)





## 动态库的配置方法

![image-20221103131340982](./assets/image-20221103131340982.png)

==第一步：包含头文件==

![image-20221103131428263](./assets/image-20221103131428263.png)

==第二步：引入lib文件==

![image-20221103131543183](./assets/image-20221103131543183.png)

![image-20221103131618227](./assets/image-20221103131618227.png)

![image-20221103131643054](./assets/image-20221103131643054.png)

> #### 可以编译成功,但是运行失败

![image-20221103131721567](./assets/image-20221103131721567.png)

> 因为Test.exe文件没有和.dll文件放在一起

![image-20221103131841013](./assets/image-20221103131841013.png)

![image-20221103131854649](./assets/image-20221103131854649.png)

问题1：

![image-20221107104901801](./assets/image-20221107104901801.png)

# 命名法则

## 匈牙利命名法

匈牙利命名法是早期的规范，由微软的一个匈牙利人发明的，是 IDE 还十分智障的年代的产物。那个年代，当代码量很多的时候，想要确定一个变量的类型是很麻烦的，不像现在 IDE 都会给提示，所以才产生了这样一个命名规范，估计现在已经没啥人用了吧……一个十分系统却又琐碎的命名规范。

该命名规范，要求前缀字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，单词第一个字母大写。

### Ex

```cpp
int iMyAge;        #  "i": int
char cMyName[10];  #  "c": char
float fManHeight;  #  "f": float
```

### 其他

前缀类型还有：

```text
a      数组（Array）
b      布尔值（Boolean）
by     字节（Byte）
c      有符号字符（Char）
cb     无符号字符（Char Byte，并没有神马人用的）
cr     颜色参考值（Color Ref）
cx,cy  坐标差（长度 Short Int）
dw     双字（Double Word）
fn     函数（Function）
h      Handle（句柄）
i      整形（Int）
l      长整型（Long Int）
lp     长指针（Long Pointer）
m_     类成员（Class Member）
n      短整型（Short Int）
np     近程指针（Near Pointer）
p      指针（Pointer）
s      字符串（String）
sz     以 Null 做结尾的字符串型（String with Zero End）
w      字（Word）
```

还有其他更多的前缀是根据微软自己的 MFC/句柄/控件/结构等东西定义的，就不过多描述了。

# 句柄

[什么是句柄？为什么会有句柄？HANDLE - MyMSDN - C++博客 (cppblog.com)](http://www.cppblog.com/mymsdn/archive/2009/02/19/handle-in-windows.html)